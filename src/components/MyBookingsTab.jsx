import { useEffect, useState } from "react";
import app from "../firebase";
import {
  getFirestore,
  collection,
  query,
  getDocs,
  where,
  doc,
  getDoc,
  deleteDoc,
  setDoc,
  updateDoc,
  Timestamp,
  serverTimestamp,
} from "firebase/firestore";
import { getAuth } from "firebase/auth";
import { useNavigate } from "react-router-dom";
import { loadStripe } from "@stripe/stripe-js";
import { cancelExpiredUnpaidAppointments } from "../utils/cancelExpiredUnpaidAppointments";
import { onAuthStateChanged } from "firebase/auth";


const db = getFirestore(app);
const auth = getAuth(app);
const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLIC_KEY);

function MyBookingsTab() {
  const [appointments, setAppointments] = useState([]);
  const [currentUser, setCurrentUser] = useState(null);
  // ‚úÖ ÈÄöÁî®ÊåâÈíÆÊ†∑ÂºèÂáΩÊï∞
const buttonStyle = (bg, border, color = "#000") => ({
  backgroundColor: bg,
  border: `1px solid ${border}`,
  color,
  padding: "0.5rem 1rem",
  borderRadius: "8px",
  cursor: "pointer",
  fontWeight: 500,
});

useEffect(() => {
  const unsubscribe = onAuthStateChanged(auth, (user) => {
    setCurrentUser(user);
  });
  return () => unsubscribe();
}, []);

  const navigate = useNavigate();

  const handleCancel = async (booking) => {
    const { id: bookingId, slotId, paid } = booking;
  
    if (paid) {
      const confirmRefund = window.confirm("This booking has been paid. Do you want to cancel and request a refund?");
      if (!confirmRefund) return;
  
      try {
        const res = await fetch("/api/refund", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ appointmentId: bookingId }),
        });
  
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text);
        }
  
        alert("‚úÖ Refund requested. It may take a few days to arrive.");
      } catch (err) {
        console.error("Refund failed:", err);
        alert("‚ùå Refund failed: " + err.message);
        return;
      }
    }
  
    // üîÑ Êó†ËÆ∫ÊòØÂê¶ÈÄÄÊ¨æÔºåÈÉΩÈáäÊîæ slot
    await deleteDoc(doc(db, "appointments", bookingId));
    await setDoc(
      doc(db, "slots", slotId),
      { available: true, userId: null, locked: false },
      { merge: true }
    );
  
    setAppointments((prev) => prev.filter((b) => b.id !== bookingId));
    alert("üóëÔ∏è Booking cancelled");
  };
  
  

  // ‚úÖ Êñ∞Â¢ûÔºöÂà§Êñ≠ÁéØÂ¢É
const API_BASE = import.meta.env.MODE === "development"
? "https://offchair.vercel.app"
: "";

const handleCheckout = async (booking) => {
  try {
    const res = await fetch(`${API_BASE}/api/create-checkout-session`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        serviceId: booking.serviceId,
        title: booking.service?.title || "ÊúçÂä°",
        amount: booking.service?.price || 100,
        userId: booking.userId,
        slotId: booking.slotId, // ‚úÖ Ë°•‰∏äËøô‰∏ÄË°å
      }),
    });

    // ‚úÖ Êñ∞Â¢ûËøô‰∏ÄÊÆµ
    if (!res.ok) {
      const text = await res.text(); // Áî® text() ÊçïËé∑ÂêéÁ´ØËøîÂõûÁöÑÈîôËØØÂÜÖÂÆπ
      console.error("‚ùå Êé•Âè£Ë∞ÉÁî®Â§±Ë¥•Ôºö", res.status, text);
      alert("ÊúçÂä°Âô®Âá∫ÈîôÔºö" + text);
      return;
    }

    // ‚úÖ Á°ÆËÆ§ÊòØÊàêÂäüÁöÑÂìçÂ∫îÂêéÔºåÂÜçËß£Êûê JSON
    const data = await res.json();

    if (data.url) {
      window.location.href = data.url;
    } else {
      alert("‚ùå Ëé∑ÂèñÊîØ‰ªòÈìæÊé•Â§±Ë¥•");
    }
  } catch (error) {
    console.error("Ë∑≥ËΩ¨ Stripe ‰ªòÊ¨æÂ§±Ë¥•:", error);
    alert("‚ùå ‰ªòÊ¨æÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï");
  }
};

  useEffect(() => {
    cancelExpiredUnpaidAppointments().then(res => {
      console.log(`‚úÖ Ëá™Âä®ÂèñÊ∂à‰∫Ü ${res.cancelled} Êù°Ë∂ÖÊó∂Êú™‰ªòÊ¨æÁöÑÈ¢ÑÁ∫¶`);
    });
  }, []);

  const handleConfirm = async (bookingId, userId) => {
    try {
      const deadline = Timestamp.fromDate(new Date(Date.now() + 60 * 60 * 1000));
      await updateDoc(doc(db, "appointments", bookingId), {
        status: "confirmed",
        paid: false,
        paymentDeadline: deadline,
        confirmedAt: serverTimestamp(),
      });

      setAppointments((prev) =>
        prev.map((b) =>
          b.id === bookingId ? { ...b, status: "confirmed", paid: false, paymentDeadline: deadline } : b
        )
      );

      alert("‚úÖ Â∑≤Á°ÆËÆ§È¢ÑÁ∫¶ÔºåÂ∑≤Â∞ùËØïÊèêÈÜíÂÆ¢‰∫∫‰ªòÊ¨æ");

      const userRef = doc(db, "users", userId);
      const userSnap = await getDoc(userRef);
      const user = userSnap.exists() ? userSnap.data() : null;

      if (user?.isMember && user.phoneNumber) {
        await fetch("/api/send-sms", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            to: user.phoneNumber,
            message: `‰Ω†È¢ÑÁ∫¶ÁöÑÊúçÂä°Â∑≤Ë¢´ÂïÜÂÆ∂Á°ÆËÆ§ÔºåËØ∑Â∞ΩÂø´‰ªòÊ¨æ‰ª•ÂÆåÊàêÈ¢ÑÁ∫¶ÔΩû`,
          }),
        });
        console.log("üì© Áü≠‰ø°ÊèêÈÜíÂ∑≤ÂèëÈÄÅÁªôÂÆ¢‰∫∫");
      } else {
        console.log("üì≠ Èùû‰ºöÂëòÊàñÊó†ÊâãÊú∫Âè∑Ôºå‰∏çÂèëÈÄÅÁü≠‰ø°");
      }
    } catch (err) {
      console.error("‚ùå Á°ÆËÆ§È¢ÑÁ∫¶Â§±Ë¥•Ôºö", err);
      alert("‚ùå Á°ÆËÆ§Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï");
    }
  };

  useEffect(() => {
    if (!currentUser) return;

    const fetch = async () => {
      const uid = currentUser.uid;

      const guestQ = query(collection(db, "appointments"), where("userId", "==", uid));
      const merchantQ = query(collection(db, "appointments"), where("serviceOwnerId", "==", uid));
      
      const [guestSnap, merchantSnap] = await Promise.all([
        getDocs(guestQ),
        getDocs(merchantQ),
      ]);
      
      const allDocs = [...guestSnap.docs, ...merchantSnap.docs];
      

      const list = await Promise.all(
        allDocs.map(async (d) => {
          const data = d.data();
          const serviceSnap = await getDoc(doc(db, "services", data.serviceId));
          const service = serviceSnap.exists() ? serviceSnap.data() : null;

          const guestSnap = await getDoc(doc(db, "users", data.userId));
          const guest = guestSnap.exists() ? guestSnap.data() : { displayName: "ÂåøÂêçÁî®Êà∑" };

          return {
            ...data,
            id: d.id,
            service,
            guest,
            serviceOwnerId: service?.userId || "",
          };
        })
      );

      const now = Date.now();
      const future = list.filter((b) => {
        const end = b.endTime?.seconds * 1000;
        return end && end > now;
      });

      const myAppointments = future.filter(
        (b) =>
          b.userId === currentUser.uid || b.serviceOwnerId === currentUser.uid
      );

      setAppointments(myAppointments);
    };

    fetch();
  }, [currentUser]);

  const handleMarkCompleted = async (booking, role) => {
    const update = {};
    if (role === "guest") update.guestCompleted = true;
    if (role === "merchant") update.merchantCompleted = true;
  
    // Â¶ÇÊûúÂèåÊñπÈÉΩÂ∑≤ÂÆåÊàêÔºåÊ∑ªÂä† completedAt
    if (
      (role === "guest" && booking.merchantCompleted) ||
      (role === "merchant" && booking.guestCompleted)
    ) {
      update.completedAt = serverTimestamp();
    }
  
    try {
      await updateDoc(doc(db, "appointments", booking.id), update);
      alert("‚úÖ Marked as completed");
  
      setAppointments((prev) =>
        prev.map((b) =>
          b.id === booking.id ? { ...b, ...update } : b
        )
      );
    } catch (err) {
      console.error("‚ùå Failed to mark as completed:", err);
      alert("Failed to update status.");
    }
  };

  const handleMerchantCancel = async (booking) => {
    const confirm = window.confirm("Are you sure you want to cancel this booking and issue a full refund?");
    if (!confirm) return;
  
    try {
      // ‚úÖ Ë∞ÉÁî®ÈÄÄÊ¨æ API
      const res = await fetch("/api/refund", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ appointmentId: booking.id }),
      });
  
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text);
      }
  
      // ‚úÖ Âà†Èô§È¢ÑÁ∫¶ + Ëß£ÈîÅ slot
      await deleteDoc(doc(db, "appointments", booking.id));
      await setDoc(doc(db, "slots", booking.slotId), {
        available: true,
        locked: false,
        userId: null,
      }, { merge: true });
  
      setAppointments((prev) => prev.filter((b) => b.id !== booking.id));
      alert("‚úÖ Booking canceled and guest has been refunded.");
    } catch (err) {
      console.error("Merchant cancel failed:", err);
      alert("‚ùå Failed to cancel booking: " + err.message);
    }
  };
  
  

  return (
    <div style={{ padding: "1rem 0" }}>
      {appointments.length === 0 ? (
        <p style={{ color: "#666", fontSize: "0.95rem" }}>You have no upcoming bookings.</p>
      ) : (
        appointments.map((b) => {
          const isGuest = b.userId === currentUser.uid;
          const isMerchant = b.serviceOwnerId === currentUser.uid;
          const now = Date.now();
          const serviceEndTime = b.endTime?.seconds * 1000 || 0;
          const gracePeriod = 6 * 60 * 60 * 1000;
          const isTimeOver = serviceEndTime + gracePeriod < now;
          const serviceCompleted =
            b.paid &&
            ((b.guestCompleted && b.merchantCompleted) || isTimeOver);
  
          const bgColor = isGuest ? "#f9f5ff" : "#f0f9ff";
          const borderColor = isGuest ? "#d8b4fe" : "#93c5fd";

          const showReminderIfNeeded = (booking) => {
            const now = Date.now();
            const start = booking.startTime?.seconds * 1000;
            const tenMinutesBefore = start - 10 * 60 * 1000;
          
            // ÊòØÂê¶ËøõÂÖ•ÊèêÈÜíÊó∂Èó¥ÊÆµ
            if (now > tenMinutesBefore && now < start) {
              const key = `reminder_shown_${booking.id}`;
              if (!localStorage.getItem(key)) {
                alert(`üîî Reminder: Your service "${booking.service?.title}" is starting in 10 minutes!`);
                localStorage.setItem(key, "true");
              }
            }
          };
            // ‚úÖ ÊèíÂú®ËøôÈáåÔºÅ
  if (isGuest && b.status === "confirmed" && b.paid) {
    showReminderIfNeeded(b);
  }
  
          return (
<div
  key={b.id}
  style={{
    backgroundColor: b.refunded ? "#f3f4f6" : bgColor,
    border: `1px solid ${b.refunded ? "#ccc" : borderColor}`,
    borderRadius: "16px",
    padding: "1.25rem",
    marginBottom: "1.5rem",
    boxShadow: "0 2px 12px rgba(0,0,0,0.05)",
    transition: "transform 0.2s ease",
    opacity: b.refunded ? 0.7 : 1,
    pointerEvents: b.refunded ? "none" : "auto",
  }}
  onMouseEnter={(e) => {
    if (!b.refunded) e.currentTarget.style.transform = "scale(1.01)";
  }}
  onMouseLeave={(e) => {
    if (!b.refunded) e.currentTarget.style.transform = "scale(1)";
  }}
>

              <h3 style={{ margin: 0, fontSize: "1.2rem", color: "#111" }}>
                {b.service?.title || "Untitled Service"}
              </h3>
  
              <p style={{ margin: "6px 0", color: "#555" }}>
                üïí {new Date(b.startTime.seconds * 1000).toLocaleString()}
              </p>
  
              <p style={{ margin: "6px 0", color: "#666", display: "flex", alignItems: "center", gap: "0.75rem" }}>
  Status: {b.status === "confirmed" ? "‚úÖ Confirmed" : "‚è≥ Waiting for confirmation"}

  {b.refunded ? (
    <span style={{
      backgroundColor: "#fee2e2",
      color: "#b91c1c",
      padding: "2px 8px",
      borderRadius: "999px",
      fontSize: "0.8rem",
      fontWeight: "bold"
    }}>
      REFUNDED
    </span>
  ) : b.paid ? (
    <span style={{
      backgroundColor: "#dcfce7",
      color: "#15803d",
      padding: "2px 8px",
      borderRadius: "999px",
      fontSize: "0.8rem",
      fontWeight: "bold"
    }}>
      PAID
    </span>
  ) : null}
</p>

{b.refunded && (
  <p style={{ color: "#888", fontStyle: "italic", marginTop: "0.5rem" }}>
    This booking has been refunded.
  </p>
)}


  
              {isGuest && b.paid && (
                <p style={{ color: "#10b981", fontSize: "0.9rem", fontWeight: 500 }}>
                  ‚úÖ Your payment has been received. This booking is confirmed.
                </p>
              )}
              {isMerchant && b.paid && (
                <p style={{ color: "#0f5132", fontSize: "0.9rem", fontWeight: 500 }}>
                  üí° The guest has paid. Please prepare for the service.
                </p>
              )}
  
              <div style={{ display: "flex", flexWrap: "wrap", gap: "0.75rem", marginTop: "0.75rem" }}>
                {isGuest && (
                  <>
                    {b.status === "confirmed" && !b.paid && (
                      <button
                        onClick={() => handleCheckout(b)}
                        style={buttonStyle("#fffbea", "#facc15", "#b45309")}
                      >
                        Pay Now üí≥
                      </button>
                    )}

<button
  onClick={() => handleCancel(b)}
  style={buttonStyle("#ffecec", "#d33", "#d33")}
>
  Cancel Booking
</button>



                    <button
                      onClick={() => {
                        const chatId = [currentUser.uid, b.service.userId].sort().join("_");
                        localStorage.setItem("chat_after_booking", chatId);
                        window.location.reload();
                      }}
                      style={buttonStyle("#fff0f3", "#ff2d55", "#ff2d55")}
                    >
                      Contact Provider
                    </button>
                    </>

                  
                )}
  
                {/* ‚úÖ Mark as Completed ÊåâÈíÆ */}
                {isGuest && b.paid && now > serviceEndTime && !b.guestCompleted && (
                  <button
                    onClick={() => handleMarkCompleted(b, "guest")}
                    style={buttonStyle("#fefce8", "#eab308")}
                  >
                    Mark as Completed ‚úÖ
                  </button>
                )}
                {isMerchant && b.paid && now > serviceEndTime && !b.merchantCompleted && (
                  <button
                    onClick={() => handleMarkCompleted(b, "merchant")}
                    style={buttonStyle("#eef2ff", "#6366f1")}
                  >
                    Mark as Completed ‚úÖ
                  </button>
                )}
  
                {/* ‚úÖ Leave a Rating */}
                {isGuest && serviceCompleted && !b.hasRated && (
                  <button
                    onClick={() => navigate(`/rate/${b.serviceId}?slotId=${b.slotId}`)}
                    style={buttonStyle("#ecfccb", "#65a30d")}
                  >
                    Leave a Rating üåü
                  </button>
                )}
  
                {isMerchant && (
                  <>
                    {b.status === "booked" ? (
                      <button
                        onClick={() => handleConfirm(b.id, b.userId)}
                        style={buttonStyle("#ff2d55", "#ff2d55", "#fff")}
                      >
                        Confirm Booking
                      </button>
                    ) : (
                      <button disabled style={buttonStyle("#f4f4f5", "#ccc", "#aaa")}>
                        Confirmed
                      </button>
                    )}
                    {/* ‚úÖ Êñ∞Â¢ûÔºöÂïÜÂÆ∂ÂèñÊ∂àÊåâÈíÆ */}
    <button
      onClick={() => handleMerchantCancel(b)}
      style={buttonStyle("#fff1f2", "#e11d48", "#e11d48")}
    >
      Cancel Booking
    </button>

                    <button
                      onClick={() => navigate(`/user/${b.userId}`)}
                      style={buttonStyle("#f4f4f5", "#ccc")}
                    >
                      View Guest Profile
                    </button>
                  </>
                )}
  
                <button
                  onClick={() => navigate(`/detail/${b.serviceId}`)}
                  style={buttonStyle("#f4f4f5", "#ccc")}
                >
                  View Service Details
                </button>
              </div>
            </div>
          );
        })
      )}
    </div>
  );
  
  
}

export default MyBookingsTab;
